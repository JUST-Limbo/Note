## 盒子模型

标准盒子模型

```css
box-sizing:content-box;
```

width 与 height 只包括内容的宽和高，不包括边框（border），内边距（padding），外边距（margin）

怪异盒子模型

```css
box-sizing:border-box;
```

width 和 height 属性包括内容，内边距和边框，但不包括外边距。

## 行内元素 块级元素 行内块元素

行内元素：

+ 设置宽高无效，根据内容撑开
+ 垂直margin无效，水平margin有效
+ 内边距无效
+ 可以和其他行内元素、块级元素共用一行

块级元素：

+ 设置宽高有效，宽度默认为父级宽度100%
+ 高度默认根据内容撑开，**没有内容则默认没有高度**
+ margin有效
+ 独占一行

行内块元素：

img、input、textarea、button

+ 设置宽高有效，自带默认宽高
+ margin有效
+ 共用一行

## ajax步骤

```js
var request = new XMLHttpRequest()  // 创建异步对象

request.onreadystatechange = function () { // 注册事件
  if (request.readyState == 4) {
    if (request.status == 200) {
      console.log('响应成功')
      console.log(request.responseText)
    } else {
      console.log('响应失败')
    }
  }
}

request.open('GET', 'http://localhost:3000') // 设置请求的参数

// post请求 设置头信息
// request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded") 

request.send() // 发送请求

// post请求 设置请求主体
// request.send(body)
// request.send("name=v1&upwd=v2")

```

## 图片懒加载

原理：图片是通过`img`的`src属性`，当对src赋值时，浏览器会请求图片资源

当img元素的offsetTop<document.body.scrollTop+document.documentElement.offsetHeight

即img进入视口的条件成立

基于这个问题，可以利用标签的自定义属性（data-xxx），来保存图片的路径，当需要加载图片时（将要进入视口时），将data-xxx赋值给src就可以实现按需加载

## CSS3新特性

grid flex

圆角

媒体查询

子代选择器

过渡transition

动画animation

转换transform

阴影

渐变

## HTML5新特性

### 一、语义标签

| 标签      | 描述                               |
| --------- | ---------------------------------- |
| <header>  | 定义了文档的头部区域               |
| <footer>  | 定义了文档的尾部区域               |
| <nav>     | 定义文档的导航                     |
| <section> | 定义文档中的节                     |
| <article> | 定义文章                           |
| <aside>   | 定义页面以外的内容                 |
| <details> | 定义用户可以看到或者隐藏的额外细节 |
| <summary> | 标签包含details元素的标题          |
| <dialog>  | 定义对话框                         |
| <figure>  | 定义自包含内容，如图表             |
| <main>    | 定义文档主内容                     |
| <mark>    | 定义文档的主内容                   |
| <time>    | 定义日期/时间                      |

### 二、增强型表单

html5修改一些新的input输入特性，改善更好的输入控制和验证

| 输入类型       | 描述                     |
| -------------- | ------------------------ |
| color          | 主要用于选取颜色         |
| date           | 选取日期                 |
| datetime       | 选取日期(UTC时间)        |
| datetime-local | 选取日期（无时区）       |
| month          | 选择一个月份             |
| week           | 选择周和年               |
| time           | 选择一个时间             |
| email          | 包含e-mail地址的输入域   |
| number         | 数值的输入域             |
| url            | url地址的输入域          |
| tel            | 定义输入电话号码和字段   |
| search         | 用于搜索域               |
| range          | 一个范围内数字值的输入域 |

html5新增了五个表单元素

| <datalist> | 用户会在他们输入数据时看到域定义选项的下拉列表 |
| ---------- | ---------------------------------------------- |
| <progress> | 进度条，展示连接/下载进度                      |
| <meter>    | 刻度值，用于某些计量，例如温度、重量等         |
| <keygen>   | 提供一种验证用户的可靠方法生成一个公钥和私钥   |
| <output>   | 用于不同类型的输出比如尖酸或脚本输出           |

html5新增表单属性

| 属性         | 描述                                  |
| ------------ | ------------------------------------- |
| placehoder   | 输入框默认提示文字                    |
| required     | 要求输入的内容是否可为空              |
| pattern      | 描述一个正则表达式验证输入的值        |
| min/max      | 设置元素最小/最大值                   |
| step         | 为输入域规定合法的数字间隔            |
| height/width | 用于image类型<input>标签图像高度/宽度 |
| autofocus    | 规定在页面加载时，域自动获得焦点      |
| multiple     | 规定<input>元素中可选择多个值         |

### 三、视频和音频

html5提供了音频和视频文件的标准，既使用<audio>元素。

音频：<audio src=" "></audio>

```html
<audio controls>    //controls属性提供添加播放、暂停和音量控件。
  <source src="horse.ogg" type="audio/ogg">
  <source src="horse.mp3" type="audio/mpeg">
您的浏览器不支持 audio 元素。        //浏览器不支持时显示文字
</audio>
```

视频：<video src=" "></video>

```html
<video width="320" height="240" controls>
  <source src="movie.mp4" type="video/mp4">
  <source src="movie.ogg" type="video/ogg">
您的浏览器不支持Video标签。
</video>
```

### 四、Canvas绘图

### 五、SVG绘图

### 六、地理定位

使用`getCurrentPosition()`方法来获取用户的位置。以实现“LBS服务”

```html
<script>
var x=document.getElementById("demo");
function getLocation()
  {
  if (navigator.geolocation)
    {
    navigator.geolocation.getCurrentPosition(showPosition);
    }
  else{x.innerHTML="Geolocation is not supported by this browser.";}
  }
function showPosition(position)
  {
  x.innerHTML="Latitude: " + position.coords.latitude +
  "<br />Longitude: " + position.coords.longitude;
  }
</script>
```

### 七、拖放API

拖放是一种常见的特性，即捉取对象以后拖到另一个位置。

在html5中，拖放是标准的一部分，任何元素都能够拖放。

```html
<div draggable="true"></div>
```

当元素拖动时，我们可以检查其拖动的数据。

```html
<div draggable="true" ondragstart="drag(event)"></div>
<script>
function drap(ev){
    console.log(ev);
}
</script>
```

| 拖动生命周期 | 属性名      | 描述                                           |
| ------------ | ----------- | ---------------------------------------------- |
| 拖动开始     | ondragstart | 在拖动操作开始时执行脚本                       |
| 拖动过程中   | ondrag      | 只要脚本在被拖动就运行脚本                     |
| 拖动过程中   | ondragenter | 当元素被拖动到一个合法的防止目标时，执行脚本   |
| 拖动过程中   | ondragover  | 只要元素正在合法的防止目标上拖动时，就执行脚本 |
| 拖动过程中   | ondragleave | 当元素离开合法的防止目标时                     |
| 拖动结束     | ondrop      | 将被拖动元素放在目标元素内时运行脚本           |
| 拖动结束     | ondragend   | 在拖动操作结束时运行脚本                       |

 

### 八、WebWorker

### 九、WebStorage

### 十、WebSocket



## GET POST请求方式的区别

GET:是从服务器上获取数据，post 是向服务器传送数据

![image-20210309211925410](前端面试.assets/image-20210309211925410.png)

### GET 方法

查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：

- GET 请求保留在浏览器历史记录中
- GET 请求可被收藏为书签
- GET 请求不应在处理敏感数据时使用
- GET 请求有长度限制
- 编码类型application/x-www-form-urlencoded
- 对数据长度有限制（url限制2048个字符）

### POST 方法

查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：

+ 编码类型常见encodedapplication/x-www-form-urlencoded或multipart/form-data
+ POST数据长度无限制
+ POST 请求不会保留在浏览器历史记录中



## axios取消请求

```js
let cancel = null
div.onclick = function () {
  if (cancel !== null) {
    cancel()
  }
  axios({
    method: 'GET',
    url: 'http://localhost:3000/get',
    cancelToken: new axios.CancelToken(function (c) {
      cance = c
    })
  }).then(res => {
    console.log(res)
    cancel = null
  })
}
```



## 单页面应用和多页面应用

|                   | 单页面应用（SinglePage Web Application，SPA）                | 多页面应用（MultiPage Application，MPA）     |
| :---------------- | :----------------------------------------------------------- | -------------------------------------------- |
| 组成              | 一个外壳页面和多个页面片段组成                               | 多个完整页面构成                             |
| 资源共用(css,js)  | 共用，只需在外壳部分加载                                     | 不共用，每个页面都需要加载                   |
| 刷新方式          | 页面局部刷新或更改                                           | 整页刷新                                     |
| url 模式          | a.com/#/pageone  a.com/#/pagetwo                             | a.com/pageone.html   a.com/pagetwo.html      |
| 用户体验          | 页面片段间的切换快，用户体验良好                             | 页面切换加载缓慢，流畅度不够，用户体验比较差 |
| 首屏              | 慢                                                           | 快                                           |
| 转场动画          | 容易实现                                                     | 无法实现                                     |
| 数据传递          | 容易                                                         | 依赖 url传参、或者cookie 、localStorage等    |
| 搜索引擎优化(SEO) | 需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化 | 实现方法简易                                 |
| 试用范围          | 高要求的体验度、追求界面流畅的应用                           | 适用于追求高度支持搜索引擎的应用             |
| 开发成本          | 较高，常需借助专业的框架                                     | 较低 ，但页面重复代码多                      |
| 维护成本          | 相对容易                                                     | 相对复杂                                     |
| 服务器压力        | 小                                                           | 大，需要负责异步请求和页面合成               |

## ES5构造函数和ES6 class的对比

1. class不能提升
2. class 只能通过new创建实例
3. class采用严格模式
4. class的原型上的属性不能被for of 等遍历

## 延迟加载JS的方式

![img](imgs/前端面试.assets/legend.svg)

`<script>`

首先定义没有任何属性的 `<script>`。当html文件在解析时，遇到到这样的js标签时，会被阻塞，此时，解析将停止，并且将发起一个js文件的网络请求（假设这个个js标签是个外链js文件）。然后在html继续解析之前会执行该js文件。

![img](imgs/前端面试.assets/893018-20210528001535976-67297434.png)

`<script async>`

**async** 属性会使得html解析和js文件下载并行执行（不会被阻塞），但是当js文件下载完成会立即执行（会阻塞html文件解析），**不保证执行顺序（不和在html文件中顺序一样，哪个脚本先下载完会先执行）**

![img](imgs/前端面试.assets/893018-20210528001747360-1404120053.png)

`<script defer>`

**defer** 属性会使得html解析和js文件下载并行执行（不会被阻塞），下载过程同 **async** 属性，会**在html完成解析后**再去执行。 **defer** 脚本执行会保证执行顺序（和在html文档中顺序保持一致）。

![img](imgs/前端面试.assets/893018-20210528002227152-1571024014.png)

**defer** 脚本会在DOMContentLoaded和load事件之前执行 。
**async** 脚本会在 load 事件之前发生，但不能保证 DOMContentLoaded 事件先后的执行顺序

## 原型链

![img](前端面试.assets/163a55d5d35b866d~tplv-t2oaga2asx-watermark.awebp)

```js
Function.prototype===Function.__proto__ // true
```

> 函数的`__proto__`指向`Function.prototype`,包括Function本身



## 内存泄露

> 指一块被分配的内存未释放或无法释放

1. 意外的全局变量
2. console.log
3. DOM泄露
4. 闭包
5. 被遗忘的计时器

在传递给`console.log`的对象是不能被垃圾回收，因为在代码运行之后需要在开发工具能查看对象信息。所以最好不要在生产环境中`console.log`任何对象。



## 重绘 回流/重排

![在这里插入图片描述](前端面试.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70.png)

![在这里插入图片描述](前端面试.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0MTk0MTk=,size_16,color_FFFFFF,t_70-16453704879177.png)

**浏览器渲染步骤**：

1. 解析html生成DOM树；解析css，生成CSSOM树，将DOM树和CSSOM树结合，生成**渲染树**；
2. 布局render树（layout、reflow），计算各元素尺寸，位置等
3. 绘制render树（painting），绘制页面元素信息
4. 最后将得到的节点位置信息交给浏览器的图形处理程序，让浏览器中显示页面

**重绘reflow**：当节点的部分属性发生变化，但不影响布局，只需要重新计算节点在屏幕中的绝对位置并渲染的过程。如background-color、visibility、color

**回流/重排repaint**：当渲染树中的节点信息发生了大小、边距等问题，需要重新计算各节点和css具体的大小和位置。

> 请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。
>
> 回流必然引起重绘，重绘不一定引起回流。

### 如何减少

1. CSS避免回流和重绘
   + 尽可能在DOM树最末端改变class
   + 避免设置多层内联样式
   + 动画效果应用到position属性为absolute或fixed上
   + 避免使用table
2. JS避免回流和重绘
   - 避免使用JS多次修改样式，尽量一次性修改完或将样式集成到一个class中
   - 尽量使用文档片段创建和操作DOM（document.createDocumentFragment()）
   - 先隐藏元素，进行修改后再显示元素（display值为none的DOM元素不会引起回流、重绘）
   - 避免循环读取offsetLeft，在循环外保存起来
   - 复杂动画效果使用绝对定位让其脱离文档流，否则会引起父元素、其他元素大量回流

## 浏览器输入URL之后发生了什么

![image-20220226235620909](前端面试.assets/image-20220226235620909.png)

## Cookie、Session、Token区别

