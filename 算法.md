## 栈 stack

又名堆栈，是一种运算受限的线性表

栈和队列是比较常见的`受限线性结构`

+ 后进先出（LIFO last in first out），后进入元素最先弹出栈空间
+ 限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。
+ 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素
+ 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素

## 队列 queue

先进先出（FIFO first in first out）

只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作

进行插入操作的端称为队尾，进行删除操作的端称为队头。

### 优先级队列

数字越小优先级越高，即优先级数字越小的元素先被处理。这是因为在优先级队列中，我们希望将具有较高优先级的元素（如紧急任务）放在队列的前面，这些元素将更快地得到处理。

## 链表 linked list

数组中的元素在内存中是连续的空间，链表不必是连续的空间

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素?fromModule=lemma_inlink)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域。 

由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间。

数组访问任何一个位置的元素时，都要从头开始访问，无法通过下标直接访问元素

**单向链表和双向链表的主要区别在于节点的指向。**

单向链表中，每个节点都只有一个指针，指向下一个节点。因此，只能从链表的头节点开始依次遍历每个节点才能找到特定的节点。这也就使得在单向链表中删除一个节点，需要将该节点的前一个节点的 `next` 指针跳过该节点，指向该节点的下一个节点。而在单向链表中插入或删除节点，需要遍历整个链表寻找正确的位置，因此其时间复杂度为 O(n)。

双向链表中，每个节点有两个指针，分别指向前一个节点和后一个节点。因此，在双向链表中可以从头尾两端开始遍历节点，也可以快速找到某个节点的前后节点。同时，在双向链表中，插入或删除节点只需要调整当前节点的前后指针，使其指向正确的节点即可，因此其时间复杂度为 O(1)。

总的来说，单向链表有一个优势，就是节点存储标识，空间上比双向链表少一半，因为双向链表每个节点都需要额外保存一个指针，占用额外空间。但在操作效率方面，双向链表具有更好的优势，因为它支持双向遍历，而且对于插入和删除操作，具有更好的效率。

## 集合 set

计算机科学中，集合是**一组可变数量**的数据项(也可能是0个)的组合，这些数据项可能共享某些特征，需要以某种操作方式一起进行操作。一般来讲，这些数据项的类型是相同的，或基类相同。**列表(或[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink))通常不被认为是集合，因为其大小固定**，但事实上它常常在实现中作为某些形式的集合使用。

**没有顺序**，没有重复元素，不能通过下标值进行访问
