## 栈 stack

又名堆栈，是一种运算受限的线性表

栈和队列是比较常见的`受限线性结构`

+ 后进先出（LIFO last in first out），后进入元素最先弹出栈空间
+ 限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。
+ 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素
+ 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素

## 队列 queue

先进先出（FIFO first in first out）

只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作

进行插入操作的端称为队尾，进行删除操作的端称为队头。

### 优先级队列

数字越小优先级越高，即优先级数字越小的元素先被处理。这是因为在优先级队列中，我们希望将具有较高优先级的元素（如紧急任务）放在队列的前面，这些元素将更快地得到处理。

## 链表 linked list

数组中的元素在内存中是连续的空间，链表不必是连续的空间

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在 行时动态生成。每个结点包括两个部分：一个是存储[数据元素](https://baike.baidu.com/item/数据元素?fromModule=lemma_inlink)的数据域，另一个是存储下一个结点地址的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)域。 

由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间。

数组访问任何一个位置的元素时，都要从头开始访问，无法通过下标直接访问元素

**单向链表和双向链表的主要区别在于节点的指向。**

单向链表中，每个节点都只有一个指针，指向下一个节点。因此，只能从链表的头节点开始依次遍历每个节点才能找到特定的节点。这也就使得在单向链表中删除一个节点，需要将该节点的前一个节点的 `next` 指针跳过该节点，指向该节点的下一个节点。而在单向链表中插入或删除节点，需要遍历整个链表寻找正确的位置，因此其时间复杂度为 O(n)。

双向链表中，每个节点有两个指针，分别指向前一个节点和后一个节点。因此，在双向链表中可以从头尾两端开始遍历节点，也可以快速找到某个节点的前后节点。同时，在双向链表中，插入或删除节点只需要调整当前节点的前后指针，使其指向正确的节点即可，因此其时间复杂度为 O(1)。

总的来说，单向链表有一个优势，就是节点存储标识，空间上比双向链表少一半，因为双向链表每个节点都需要额外保存一个指针，占用额外空间。但在操作效率方面，双向链表具有更好的优势，因为它支持双向遍历，而且对于插入和删除操作，具有更好的效率。

## 集合 set

计算机科学中，集合是**一组可变数量**的数据项(也可能是0个)的组合，这些数据项可能共享某些特征，需要以某种操作方式一起进行操作。一般来讲，这些数据项的类型是相同的，或基类相同。**列表(或[数组](https://baike.baidu.com/item/数组/3794097?fromModule=lemma_inlink))通常不被认为是集合，因为其大小固定**，但事实上它常常在实现中作为某些形式的集合使用。

**没有顺序**，没有重复元素，不能通过下标值进行访问 

## 哈希表 hashtable

是根据关键码值(Key value)而直接进行访问的数据结构，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。

没有顺序，不能遍历，key不能重复，不能充分利用所有单元，不能快速找出最大最小值等特殊元素

## 树 tree

它是由n(n≥0)个有限节点组成一个具有层次关系的集合。

每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点（r）；除了根节点外，每个子节点可以分为多个**不相交**的子树（subtree）。

孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；

节点的度：一个节点含有的子节点的个数称为该节点的度；

树的度：一棵树中，最大的节点的度称为树的度；

叶节点或终端节点：度为0的节点称为叶节点；

非终端节点或分支节点：度不为0的节点；

双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；

兄弟节点：具有相同父节点的节点互称为兄弟节点；

节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

树的高度或深度：树中节点的最大层次；

堂兄弟节点：双亲在同一层的节点互为堂兄弟；

节点的祖先：从根到该节点所经分支上的所有节点；

子孙：以某节点为根的子树中任一节点都称为该节点的子孙；

森林：由棵互不相交的树的集合称为森林。

叶节点个数=度为2的非页节点个数+1

无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树；
有序树：树中任意节点的子结点之间有顺序关系，这种树称为有序树；
二叉树：每个节点最多含有两个子树的树称为二叉树；
满二叉树/完美二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树；
完全二叉树：除最后一层外，所有层都是满节点，且最后一层缺右边连续节点的二叉树称为完全二叉树；
哈夫曼树（最优二叉树）：带权路径最短的二叉树称为哈夫曼树或最优二叉树。

### 二叉搜索树

二叉搜索树，又称二叉查找树、有序二叉树，是一种特殊的二叉树。它具有以下特点：

1. 左子树上所有节点的值均小于它的根节点的值
2. 右子树上所有节点的值均大于它的根节点的值
3. 左右子树也分别为二叉搜索树（递归定义）

这些特性保证了二叉搜索树中的任何节点，**在树中搜索时的时间复杂度为 O(log n)**，使得二叉搜索树成为一种非常高效的数据结构。（实际上是二分查找的思想）

二叉搜索树可以支持插入、查找、删除等操作。对于插入一个节点，我们从根节点开始比较，根据节点值大小，分别向左或向右遍历直到找到合适的插入位置。查找和删除操作也是类似的，都需要从根节点开始遍历树，找到对应的节点进行查找或删除。

需要注意的是，二叉搜索树是基于节点值大小实现的，而不是根据节点位置实现的。如果节点值的分布特别不均匀，很可能会导致二叉搜索树退化成链表，使得树的操作变得非常低效。因此，在实际使用二叉搜索树时，需要对节点的值分布进行平衡，常见的平衡二叉搜索树有 AVL 树和红黑树。
