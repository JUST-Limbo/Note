# 前端笔记

## ES6使用require引入图片

静态路径引入

```js
var imgUrl = require('../images/001.png');
```

不能使用动态路径引入图片，会报错

```js
var ImgSrc = "../images/001.png";
var img = require(ImgSrc)
```

因为require是打包工具所需要的标识，你写成运行时通过变量定义，是无法获取到，没办法打包。

require()写入的必须是path

```js
 1. var imgSrc = "001.png";
require("../../asset/images/" + imgSrc);
 2. var imgName = "001";
require(`../../asset/images/${imgName}.png`);
```



## forin的循环顺序

不一定根据定义时的顺数输出，所有浏览器的最新版本现在都按chrome执行，先把当中的非负整数键提出来，排序好输出，然后将剩下的定义时的顺序输出。



## tabIndex

**tabindex**指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用Tab键，因此得名）。

它接受一个整数作为值，具有不同的结果，具体取决于整数的值：

- tabindex=负值 (通常是tabindex=“-1”)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用JS做页面小组件内部键盘导航的时候非常有用。
- `tabindex="0"` ，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的DOM结构来决定的。
- tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序按照**tabindex** 的数值递增而滞后获焦。如果多个元素拥有相同的 **tabindex**，它们的相对顺序按照他们在当前DOM中的先后顺序决定。



## 事件循环

浏览器是多线程的，但是JS是异步单线程

1. **GUI渲染线程（DOM/BOM）**
2. **JS引擎线程（web worker）**
3. **浏览器事件线程（onclick）**
4. 定时器触发线程
5. http异步线程
6. EventLoop（事件循环）处理线程

```html
<body>
  <button id="button">button</button>
  <script>
    const button=document.getElementById("button");
    button.addEventListener("click",()=>{
      Promise.resolve().then(()=>{console.log('m1');})
      console.log('l1');
    })
    button.addEventListener("click",()=>{
      Promise.resolve().then(()=>{console.log('m2');})
      console.log('l2');
    })
  </script>
</body>
// 两个click都是宏任务,不关联
// l1
// m1 
// l2
// m2
```

```html
<body>
  <button id="button">button</button>
  <script>
    const button=document.getElementById("button");
    button.addEventListener("click",()=>{
      Promise.resolve().then(()=>{console.log('m1');})
      console.log('l1');
    })
    button.addEventListener("click",()=>{
      Promise.resolve().then(()=>{console.log('m2');})
      console.log('l2');
    })
    button.click()
  </script>
</body>
// 模拟浏览器点击 执行整个宏任务13行开始执行,触发4 9两个click(同步),click执行完后13行结束,进微任务
// l1 
// l2
// m1 
// m2
```



## axios参数格式化 get请求传递数组

axios发起get请求需要传递params参数作为URL参数。

如果params中包含数组，则Request URL表现形式形为`https://xxxx/get?arr[]=1&arr[]=2`。

如果想要其格式为`https://xxxx/get?arr=1&arr=2`，则需要手动做序列化，axios有专门的配置项用作params序列化

```js
// `paramsSerializer` 是一个负责 `params` 序列化的函数
// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)
paramsSerializer: function(params) {
	return Qs.stringify(params, {arrayFormat: 'repeat'})
},
```

qs序列化参数

```js
qs.stringify({ids: [1, 2, 3]}, { indices: false })
//  ids=1&ids=2&ids=3

qs.stringify({ids: [1, 2, 3]}, { indices: true })
//  ids[0]=1&ids[1]=2&id[2]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘repeat‘}) 
// ids=1&ids=2&ids=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘brackets‘})
 // ids[]=1&ids[]=2&ids[]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘indices‘})
// ids[0]=1&ids[1]=2&ids[2]=3

qs.stringify({ids: [1, 2, 3]}, {arrayFormat: ‘comma‘}) 
// ids[0]=1&ids[1]=2&ids[2]=3
```



## pointer-events和cursor

如果使用`pointer-evnets:none;`则该元素及其后代元素的`cursor`配置不生效，其鼠标样式为默认样式。但是如果该元素的后代元素的`pointer-events`为其他值时，则鼠标事件可以指向该后代元素。



## 强调内容的标签

`q标签`，将文本内容用`""`包含起来

`blockquote标签`表示其中文字为引用，渲染时会有一定缩进

`mark标签`突出高亮显示文字，渲染效果同常用浏览器的`crtl + F `。除此外，语法高亮通常使用`strong标签`配合css语法来实现定制化。



## 弹性布局末行对齐的应对方法（宫格）

[让CSS flex布局最后一行列表左对齐的N种方法 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2019/08/css-flex-last-align/)

[伪类匹配列表数目实现微信群头像CSS布局的技巧 « 张鑫旭-鑫空间-鑫生活 (zhangxinxu.com)](https://www.zhangxinxu.com/wordpress/2019/03/nth-last-child-css-layout/)

## Referer

**`Referer`** 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 `Referer` 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。

在以下两种情况下，`Referer` 不会被发送：

- 来源页面采用的协议为表示本地文件的 "file" 或者 "data" URI；
- 当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）。

作用：

1. 防盗链
2. 防止恶意请求

[http请求头中Referer的含义和作用_小刘学安卓的博客-CSDN博客_请求头中的referer](https://blog.csdn.net/liuqinhou/article/details/126224164)

[Window.open() - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open)

[Referrer Policy 介绍 | JerryQu 的小站 (imququ.com)](https://imququ.com/post/referrer-policy.html)

[Referrer Policy 介绍「续」 | JerryQu 的小站 (imququ.com)](https://imququ.com/post/referrer-policy-2.html)

[referrer策略和meta标签的问题_thlzjfefe的博客-CSDN博客_referrer 策略](https://blog.csdn.net/thlzjfefe/article/details/123538564)

## window.open

在https协议下，window.open打开http链接在浏览器上失败，部分设备未复现，可能和浏览器版本或浏览器本地安全策略有关。

[window.open 前端下载文件，被拦截 或者显示无法安全下载问题_Qlily_ing的博客-CSDN博客](https://blog.csdn.net/Qlily_ing/article/details/109054974)

https://blog.csdn.net/qq_41784169/article/details/117423654

https://blog.csdn.net/fjh1997/article/details/113624138

[https下使用window.open()或a标签下载文件失败的问题 - 简书 (jianshu.com)](https://www.jianshu.com/p/3a74ac9088b9)
