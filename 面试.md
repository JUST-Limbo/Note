# 面试题

## vue

### v-if和v-for为什么不应该一起用

当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中



### 计算属性computed的特点

+ 默认`computed`也是一个`watcher`是具备缓存的，只有当依赖的属性发生变化时才更新视图层。

+ 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。

+ 计算属性默认只有 `getter`，不过在需要时你也可以提供一个`setter`：

```vue
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。



### 侦听属性watch的特点

+ 不支持缓存，数据变，直接会触发相应的操作

+ watch支持异步

+ 监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值



### v-if 和 v-show 的区别

v-if ：创建或销毁DOM元素。支持`<template>`语法；

v-show：当v-show赋值为false时，元素被隐藏，此时查看代码时，该元素上会多一个内联样式style=“display:none”。



### 组件中的data为什么是一个函数

一个组件被复用多次的话，也就会创建多个实例。本质上，`这些实例用的都是同一个构造函数`。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。



### vue组件通讯

+ vuex
+ provide/inject
+ vue-router
+ props/$emit
+ 事件总线
+ $ref $parent $children $root
+ slot

### provide/inject

Vuex 和 provide/inject 最大的区别在于，Vuex 中的全局状态的每次修改是可以追踪回溯的，而 provide/inject 中变量的修改是无法控制的。

> 提示：`provide` 和 `inject` 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。（在根组件中将组件本身注入 provide，此时，我们可以在后代组件中任意访问根组件中的所有状态，根组件就成为了全局状态的容器）

```vue
// 根组件提供将自身提供给后代组件
export default {
  provide () {
    return {
      app: this
    }
  },
  data () {
    return {
      text: 'bar'
    }
  }
}

// 后代组件注入 'app'
<template>
	<div>{{this.app.text}}</div>
</template>
<script>
  export default {
    inject: ['app'],
    created() {
      this.app.text = 'baz' // 在模板中，显示 'baz'
    }
  }
</script>

```



### $attrs $listeners

`$attrs`表示父组件传给子组件且在子组件中不作为`prop`识别的标签属性（包括静态属性，动态属性，`class`和`style`属性除外）,可以通过`v-bind="$attrs"`传递给更下一级的组件。

`$listeners`包含了父组件给子组件的`v-on`事件监听器（`.native`修饰器修饰的监听器除外）。可以通过`v-on="$listeners"` 传递给更下一级的组件。



### 事件总线	eventBus

定义一个vue对象作为eventBus，让其代为订阅发布事件，进行通讯。

#### 1.定义eventBus文件

```
<script>
export default new Vue({
  name: 'eventBus',
  data() {
    return {
      // code
    }
  }
})
</script>
```

引用eventBus

```
import eventBus from './js/bus.js'; 
```

#### 2.发布（声明）事件

```
created() {  
    eventBus.$on('getTarget', target => {  
        console.log(target);  
    });  
}  
```

#### 3.订阅（触发）事件

```
methods: {  
   addCart(event) {  
       eventBus.$emit('getTarget', event.target);   
   }  
}
```



