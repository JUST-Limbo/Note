# 面试题

## vue

### v-if和v-for为什么不应该一起用

当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中



### 计算属性computed的特点

+ 默认`computed`也是一个`watcher`是具备缓存的，只有当依赖的属性发生变化时才更新视图层。

+ 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。

+ 计算属性默认只有 `getter`，不过在需要时你也可以提供一个`setter`：

```vue
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

现在再运行 `vm.fullName = 'John Doe'` 时，setter 会被调用，`vm.firstName` 和 `vm.lastName` 也会相应地被更新。



### 侦听属性watch的特点

+ 不支持缓存，数据变，直接会触发相应的操作

+ watch支持异步

+ 监听的函数接收两个参数，第一个参数是最新的值，第二个参数是输入之前的值



### v-if 和 v-show 的区别

v-if ：创建或销毁DOM元素。支持<template>语法；

v-show：当v-show赋值为false时，元素被隐藏，此时查看代码时，该元素上会多一个内联样式style=“display:none”。



### 组件中的data为什么是一个函数

一个组件被复用多次的话，也就会创建多个实例。本质上，`这些实例用的都是同一个构造函数`。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。



### vue通讯

